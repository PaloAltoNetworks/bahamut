# Bahamut

Bahamut is a Go library that provides everything you need to set up a full blown API server based on an [Elemental](https://github.com/aporeto-inc/elemental) model generated from a [Monolithe Specification](https://github.com/aporeto-inc/monolithe).

The main concept of Bahamut is to only write core business logic, and letting it handle all the boring bookkeeping. You can implement various Processors interfaces, and register them when you start a Bahamut Server.

The included Monolithe plugin generates all the needed routes and handlers to reroute the client requests to the correct method of the correct processor. Those handlers will perform basic operations, like validating the request's data are valid and conform to the specifications. When your processor is finally called, you can be sure that all basic possible errors have been checked and that you can safely assume everything is ready to be stored, retrieved, or computed.

A Bahamut Server is not directly responsible for storing an retrieving data from a database. To do so, you can use any backend library you like in your processors, but we recommend using [Manipulate](https://github.com/aporeto-inc/manipulate), which provides a common interface for manipulating an Elemental model and multiple implementations for MongoDB, Cassandra or MemDB (with more to come). Later on, switching from Cassandra to MongoDB will be a no brainer.



## Prerequisites

Install Monolithe and the Bahamut plugin:

    $ pip install 'git+https://github.com/aporeto-inc/monolithe.git'
    $ pip install 'git+https://github.com/aporeto-inc/bahamut.git#subdirectory=monolithe'



## Installation

To get the Bahamut Go Library, Run:

    $ go get -u github.com/aporeto-inc/bahamut



## Getting Started

This section explains how to build a very simple Bahamut application from scratch. It will serve one single API `GET /greetings` api that returns the quote of the day from a third party service.

> NOTE: Using Bahamut for such a simple example is of course completely overkill :)

> NOTE: You should be confortable with the concepts of Monolithe, before going any further.


### Package Structure

> NOTE: the following example assumes your source code path  is `$GOPATH/src/github.com/aporeto-inc/greetings`. You want to use something different, you'll need to adapt the example.

A commonly used package structure for a Bahamut project is usually the following:

    models/
    processors/
    specs/
    main.go

- The `models` folder will be populated by the autogenerated Elemental model files.
- The `processors` folder contains your implementation of the processors.
- The `specs` folder contains the Monolithe Specifications.

Let's create this structure:

```bash
mkdir -p {models,handlers,processors,routes,specs}
touch specs/api.info specs/monolithe.ini specs/root.spec specs/greeting.spec
touch processors/greetings.go main.go
```

#### Monolithe Specification

First we need to describe our service by creating a simple Monolithe Specification.

> NOTE: The GUI called Specification Director is available to deal with more complex specification, but for this example, plain text editing is sufficient.

Edit `specs/monolithe.ini`:

```ini
[monolithe]
product_name = Greetings

[transformer]
output = codegen
name = models
version = 1.0

[bahamut]
base_package = github.com/aporeto-inc/greetings
models_package_package = github.com/aporeto-inc/greetings/models
models_package_name = models
```

Edit `specs/api.info`:

```json
{
  "prefix": "api",
  "root": "root",
  "version": "1.0"
}
```

Edit `specs/root.spec`:

```json
{
    "attributes": [],
    "children": [
        {
            "get": true,
            "create": true,
            "relationship": "root",
            "rest_name": "greeting"
        }
    ],
    "model": {
        "entity_name": "Root",
        "resource_name": "root",
        "rest_name": "root",
        "root": true,
        "get": true
    }
}
```

Finally, edit `specs/greeting.spec`:

```json
{
    "attributes": [
        {
            "description": "The content message",
            "exposed": true,
            "name": "message",
            "type": "string"
        }
    ],
    "children": [],
    "model": {
        "description": "Represent a greeting message.",
        "extends": [],
        "package": "main",
        "resource_name": "greetings",
        "rest_name": "greeting",
        "entity_name": "Greeting"
    }
}
```

This specification describes a single read-only object API `/greetings` that returns a list of `greeting` objects, each containing a `message` attribute.

To generate and install the Elemental model from the specification, run:

    $ monogen -f specs -L elemental
    $ cp codegen/elemental/1.0/*.go models

You can take now a look at the autogenerated code in the `models` package.

> NOTE: We usually use a Makefile in order to simply run `make codegen` everytime we need it.

> NOTE: You can safely delete the `codegen` directory after having generated what you need.


#### The Greetings Processor

A processor is responsible for anything that cannot be deduced from the specification. It can be used to create more objects, storing them into a DB, forwarding the request to some other services, or whatever you like.

We are going to use a simple online quote service to return a random quote as the greeting message.

We will only implement the `RetrieveManyProcessor` interface.

Edit `processors/greetings.go`:

```go
package processors

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/aporeto-inc/bahamut"
	"github.com/aporeto-inc/greetings/models"
)

// GreetingsProcessor processes greetings requests.
type GreetingsProcessor struct{}

// NewGreetingsProcessor returns a new GreetingsProcessor.
func NewGreetingsProcessor() *GreetingsProcessor {
	return &GreetingsProcessor{}
}

// ProcessRetrieveMany retrieves a list of quotes.
func (p *GreetingsProcessor) ProcessRetrieveMany(ctx *bahamut.Context) error {

	n := 1

	// Check if we have the parameter "n" asking for more than one quote.
	if ns := ctx.Request.Parameters.Get("n"); ns != "" {
		var err error
		n, err = strconv.Atoi(ns)
		if err != nil {
			return err
		}
	}

	// Initialize the models.GreetingsList that will contains the models.Greeting.
	greetings := models.GreetingsList{}

	// Create a quick and dirty structure for unmarshaling the quote.
	var data []struct{ Content string }

	for i := 0; i < n; i++ {

		// Retrieve the quote.
		resp, err := http.Get("https://quotesondesign.com/wp-json/posts?filter[orderby]=rand")
		if err != nil {
			return err
		}

		// Unmarshal it.
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			return err
		}

		// Create a new Greeting object and set its message.
		g := models.NewGreeting()
		g.Message = data[0].Content

		// Append it to the GreetingLists.
		greetings = append(greetings, g)
	}

	// Set the output data of the context that will be returned to the user.
	ctx.OutputData = greetings

	// Happily return no error.
	return nil
}
```


#### The Main file

The `main.go` is responsible for configuring and starting your Bahamut server.

Edit `main.go`:

```go
package main

import (
	"github.com/aporeto-inc/bahamut"

	"github.com/aporeto-inc/greetings/models"
	"github.com/aporeto-inc/greetings/processors"
)

func main() {

	// Bahamut API Server configuration
	bahamutConfig := bahamut.Config{}
	bahamutConfig.ReSTServer.ListenAddress = ":9999"
	bahamutConfig.Model.RelationshipsRegistry = models.Relationships()
	bahamutConfig.Model.IdentifiablesFactory = models.IdentifiableForIdentity
	bahamutConfig.ProfilingServer.Disabled = true // Disable ProfilingServer for now
	bahamutConfig.HealthServer.Disabled = true // Disable HealthServer for now

	// Create a Bahamut server with a minimal API configuration and an empty push config.
	server := bahamut.NewServer(bahamutConfig)

	// Register your GreetingsProcessor for the GreetingIdentity.
	bahamut.RegisterProcessorOrDie(server, processors.NewGreetingsProcessor(), models.GreetingIdentity)

	// And start the server.
	server.Start()
}

```

### Try it

Now run

    go build && ./greetings


The try it:

    curl http://127.0.0.1:9999/greetings?n=2 | jq

This will output:

```json
[
  {"message": "Design is the body language of your marketing. Don't slouch."},
  {"message": "There is an unmistakeable difference between a bag of rabbit parts and a rabbit."}
]
```

## What's next?

We've only scratched the surface of what Bahamut can do. In addition to making it very easy to build an API service, Bahamut provides the following:

- A Push system based on websocket to notify the clients for changes (via local channels, Kafka or your own implementation)
- Support for Authentication via the Authenticator interface.
- Support for Authorization via the Authorizer interface.
- Easy encryption (with or without mutual TLS authentication).
- Helpers to make the use of pagination and parameters easy.
- Much more...

You can check out a more advanced example that uses a Manipulator to store the data [in the example folder](https://github.com/aporeto-inc/bahamut/tree/master/example) of this repository.

Have fun!
