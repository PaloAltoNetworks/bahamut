// Author: Antoine Mercadal
// See LICENSE file for full LICENSE
// Copyright 2016 Aporeto.

package bahamut

import (
	"fmt"

	"github.com/aporeto-inc/elemental"

	uuid "github.com/satori/go.uuid"
)

// A Context contains all information about a current operation.
//
// It contains various Info like the Headers, the current parent identity and ID
// (if any) for a given ReST call, the children identity, and other things like that.
// It also contains information about Pagination, as well as elemental.Idenfiable (or list Idenfiables)
// the user sent through the request.
type Context struct {

	// Info contains various request related information.
	Request *elemental.Request

	// Page contains various information about the pagination.
	Page *Page

	// Count contains various information about the counting of objects.
	Count *Count

	// InputData contains the data sent by the client. It can be either a single *elemental.Identifiable
	// or a []*elemental.Identifiable.
	InputData interface{}

	// OutputData contains the information that you want to send back to the user. You will
	// mostly need to set this in your processors.
	OutputData interface{}

	// StatusCode contains the HTTP status code to return.
	// Bahamut will try to guess it, but you can set it yourself.
	StatusCode int

	// // Operation contains the current request Operation.
	// Operation elemental.Operation

	// UserInfo allows you to store any additional opaque data.
	UserInfo interface{}

	// Metadata is contains random user defined metadata.
	Metadata map[string]interface{}

	id     string
	events elemental.Events
}

// NewContext creates a new *Context for the given Operation.
//
// This is mostly used by autogenerated code, and you should not need to use it manually.
func NewContext() *Context {

	return &Context{
		Request:  elemental.NewRequest(),
		Page:     newPage(),
		Count:    newCount(),
		Metadata: map[string]interface{}{},

		id:     uuid.NewV4().String(),
		events: elemental.Events{},
	}
}

// ReadElementalRequest reads information from the given elemental.Request and polulate the Context.
func (c *Context) ReadElementalRequest(req *elemental.Request) error {

	c.Request = req
	c.Page.fromElementalRequest(req)

	return nil
}

// Identifier returns the unique identifier of the context.
func (c *Context) Identifier() string {

	return c.id
}

// EnqueueEvents enqueues the given event to the Context.
//
// Bahamut will automatically generate events on the currently processed object.
// But if your processor creates other objects alongside with the main one and you want to
// send a push to the user, then you can use this method.
//
// The events you enqueue using EnqueueEvents will be sent in order to the enqueueing, and
// *before* the main object related event.
func (c *Context) EnqueueEvents(events ...*elemental.Event) {

	c.events = append(c.events, events...)
}

// SetEvents set the full list of Errors in the Context.
func (c *Context) SetEvents(events elemental.Events) {

	c.events = events
}

// HasEvents returns true if the context has some custom events.
func (c *Context) HasEvents() bool {

	return len(c.events) > 0
}

// Events returns the current Events.
func (c *Context) Events() elemental.Events {

	return c.events
}

func (c *Context) String() string {

	return fmt.Sprintf("<context id:%s request:%s page:%s count:%s>",
		c.Identifier(),
		c.Request,
		c.Page,
		c.Count,
	)
}
